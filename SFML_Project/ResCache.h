#pragma once

#include "EngineStd.h"
#include "ResHandle.h"
#include <SFML\Graphics.hpp>
#include <SFML\Audio.hpp>
#include <SFML\OpenGL.hpp>
#include <iostream>
#include "TypeId.h"

/* 
TODO: load from resource type specific or general archive in release mode.
For instance:


#ifndef DEBUG

char *buffer = NULL;
unsigned int size;

ZipFile zipFile;
if (zipFile.Init(resFileName)) //value of resFileName should come from compiled project configuration generated by external editor.
{
optional<int> index = zipFile.Find(name);
if (index.valid())
{
size = zipFile->GetFileLen(*index);
buffer = new char[size];
if (buffer)
{
zipFile.ReadFile(*index, buffer);
}
}
}

res->loadFromMemory(buffer, size);

delete[] buffer;

#endif
*/

template<class R>
class ResCache
{
	template<class T>
	friend class ResHandle;
protected:
	std::list< shared_ptr< ResHandle< R > > > m_lru;
	std::unordered_map< std::string, shared_ptr< ResHandle< R > > > m_resources;

	shared_ptr< ResHandle< R > > Find(std::string name)
	{
		return m_resources[name];
	}

	const void Update(shared_ptr< ResHandle< R > > handle)
	{
		m_lru.remove(handle);
		m_lru.push_front(handle);
	}

	shared_ptr< ResHandle< R > > Load(std::string name)
	{
		shared_ptr< ResHandle< R > > handle;

		R* res = new R();

		if(!res->loadFromFile(name)) 
		{
			std::cerr << "Resource load failure. Type: " << TypeId<R>::name() << " Path: " << name << std::endl;
		}

		handle = shared_ptr< ResHandle< R > >(
			new ResHandle<R>(name, res));

		if(handle) //Marked for removal, loadFromFile handles loading exceptions.
		{
			m_lru.push_front(handle);
			m_resources[name] = handle;
		}

		return handle;
	}

	template<typename T>
	shared_ptr< ResHandle< R > > Load(std::string name, T arg2)
	{
		shared_ptr< ResHandle< R > > handle;

		R* res = new R();

		decltype(R::loadFromFile) type;

		if(!res->loadFromFile(name, arg2))
		{
			std::cerr << "Resource load failure. Type: " << TypeId<R>::name() << " Path: " << name << std::endl;
		}

		handle = shared_ptr< ResHandle< R > >(
			new ResHandle<R>(name, res));

		if(handle) //Marked for removal, loadFromFile handles loading exceptions, else may not be reachable.
		{
			m_lru.push_front(handle);
			m_resources[name] = handle;
		}
		else
		{
			return shared_ptr< ResHandle< R > >();
		}

		return handle;
	}

	void Free(shared_ptr< ResHandle< R > > gonner);

	void FreeOneResource()
	{
		std::list< shared_ptr< ResHandle< R > > >::iterator gonner = m_lru.end();
		gonner--;
		shared_ptr< ResHandle< R > > handle = *gonner;
		m_lru.pop_back();
		m_resources.erase(handle->m_name);
	}

public:

	~ResCache()
	{
		while (!m_lru.empty())
		{
			FreeOneResource();
		}
	}

	shared_ptr< ResHandle < R > > GetHandle(std::string name)
	{
		shared_ptr< ResHandle< R > > handle(Find(name));

		if (handle == nullptr)
		{
			handle = Load(name);
		}
		else
		{
			Update(handle);
		}

		return handle;
	}

	template<typename T>
	shared_ptr< ResHandle < R > > GetHandle(std::string name, T arg2)
	{
		shared_ptr< ResHandle< R > > handle(Find(name));
		if (handle == nullptr)
		{
			handle = Load(name, arg2);
		}
		else
		{
			Update(handle);
		}

		return handle;
	}

	void Flush()
	{
		auto pred = [](const shared_ptr<ResHandle<R>>& ptr){ return ptr.use_count() < 3; };

		std::list< shared_ptr< ResHandle< R > > >::iterator it = std::find_if(m_lru.begin(), m_lru.end(), pred);
		while(it != m_lru.end())
		{

			if(it != m_lru.end()) 
			{
				shared_ptr< ResHandle< R > > handle = *it;
				m_resources.erase(handle->m_name);
				m_lru.erase(it);
			}

			it = std::find_if(m_lru.begin(), m_lru.end(), pred);
		}
	}

	//int Preload(const std::regex pattern, void (*progressCallback)(int, bool &)); To be implemented alongside map loading semantics.
	//void Flush(void); Trivial, to be implemented.
};